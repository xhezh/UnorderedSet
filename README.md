UnorderedSet

    Ограничение времени	5 секунд
    Ограничение памяти	256.0 Мб
    Ввод	стандартный ввод или input.txt
    Вывод	стандартный вывод или output.txt

UnorderedSet

Реализуйте шаблонный класс UnorderedSet, аналог std::unordered_set, который основан на хешировании методом цепочек с динамическим увеличением числа корзин.

Метод цепочек предполагает хранение массива, в каждой ячейке которого лежит корзина - список вставленных элементов с одинаковыми хеш-значениями. Среднее время операций над такой структурой пропорционально степени загруженности таблицы (load_factor = n_elements / n_buckets). При превышении load_factor некоторого значения (в задании = 1) происходит перехеширование - создание нового массива корзин в, например, 2 раза большего размера и перенос старых элементов в новые корзины.

В простейшем варианте достаточно хранить вектор (std::vector) списков (std::list / std::forward_list) и выполнять операции над ним. Более эффективные техники описаны ниже в дополнительных заданиях.

Базовая часть

Шаблонный класс UnorderedSet должен быть параметризован типом ключа KeyT. Стратегия расширения такая же как в задаче String - при добавлении элемента в пустую таблицу число корзин становится равным 1, при добавлении элемента в полную таблицу число корзин увеличивается в 2 раза (таблица считается полной, если число корзин совпадает с числом элементов, то есть load_factor == 1). В качестве хеш-функции воспользуйтесь std::hash. std::hash отображает объекты в диапазон size_t, чтобы получить индекс корзины, возьмите остаток от деления полученного числа на количество корзин.

Набор методов включает:

Конструктор по умолчанию. Создает пустую хеш-таблицу.

Конструктор от числа корзин count. Создает хеш-таблицу с count пустыми корзинами.

Конструктор от промежутка заданного двумя Forward итераторами. Создает хеш-таблицу с числом корзин равным числу элементов в последовательности, а затем вставляет элементы в таблицу.

Конструкторы копирования, перемещения, а также присваивания должны работать корректно.

Методы Size, Empty, Clear с привычной семантикой.

Методы вставки Insert(const KeyT&), Insert(KeyT&&).

Метод удаления Erase(const KeyT&).

Метод поиска bool Find(const KeyT&).

Метод Rehash(new_bucket_count). Изменяет число корзин в хеш-таблице с перехешированием. Если new_bucket_count совпадает с текущим количеством корзин или меньше числа элементов (load_factor становится больше 1), то ничего делать не нужно.

Метод Reserve(new_bucket_count). То же, что и Rehash, но не уменьшает число корзин, то есть срабатывает, если new_bucket_count превышает текущее количество корзин.

Методы BucketCount (возвращает число корзин в таблице), BucketSize(id) (возвращает размер корзины с номером id), Bucket(key) (возвращает номер корзины, в которую попадает объект key), LoadFactor() (возвращает степень заполненности таблицы).

Обратите внимание, что каждый раз создавать новые узлы списков при перехешировании может быть неэффективно. Для переиспользования старых узлов (перебрасывания указателей старых списков) рассмотрите возможность использования метода std::list::splice.

